## Запуск полного стэка сервиса

1. Build the Docker image:
   ```bash
   docker-compose build
   ```

2. Run the Flask application:
   ```bash
   docker-compose up
   ```
   
Веб приложение будет доступно по адресу `http://localhost:5000`.

# Модуль для парсинга документов .docx

Этот модуль предназначен для парсинга документов формата .docx и преобразования их содержимого в HTML. В данном описании представлен обзор работы модуля, включая основные классы и функции, используемые для обработки документов.

## Структура модуля

Модуль состоит из следующих файлов:

- `__init__.py`
- `core.py`
- `ml.py`
- `numbering.py`
- `ooxml.py`
- `export.py`

## Описание файлов

### `__init__.py`

Этот файл инициализирует модуль и импортирует основные классы из других файлов:

- `DocHandler` из `ooxml.py` для обработки документа.
- `DocHTML` из `export.py` для экспорта документа в HTML.

### `core.py`

Содержит основные классы для обработки параграфов и таблиц в документе:

- `Node`: Базовый класс для представления узлов в иерархии документа.
- `ParHandler`: Обрабатывает параграфы, извлекая текст, стили и XML-представление.
- `TableHandler`: Обрабатывает таблицы, извлекая их размеры, содержимое и определяя, являются ли они рамками.
- `CellHandler`: Обрабатывает ячейки таблиц, извлекая их содержимое и размеры.
- `TableView`: Представляет таблицу в виде узла иерархии документа.
- `DocRoot`: Представляет корневой узел документа.

### `ml.py`

Содержит класс для классификации текста с использованием модели BERT:

- `BERTTextClassifier`: Классифицирует текст, используя предобученную модель BERT.

### `numbering.py`

Содержит классы и функции для обработки нумерации и стилей в документе:

- `NumberingDB`: Обрабатывает нумерацию и стили параграфов, используя XML-представление документа.
- `find_manual_numbering`: Определяет ручную нумерацию в тексте.
- `int_to_roman`: Преобразует целое число в римскую цифру.

### `ooxml.py`

Содержит основной класс для обработки документа и преобразования его содержимого в HTML:

- `DocHandler`: Основной класс, который обрабатывает документ, извлекая параграфы и таблицы, и формирует их в иерархию.
- `table_extend`: Определяет, могут ли две таблицы быть объединены.
- `concat_tables`: Объединяет две таблицы.

## Ход процесса парсинга

1. **Импортирование документа**: Используется библиотека `docx` для загрузки документа.
2. **Инициализация обработчика**: Создается экземпляр класса `DocHandler`, который принимает документ и настройки.
3. **Обработка документа**: Вызывается метод `process` класса `DocHandler`, который:
   - Итерирует по содержимому документа.
   - Обрабатывает параграфы с помощью `ParHandler`.
   - Обрабатывает таблицы с помощью `TableHandler`.
4. **Формирование иерархии**: Для каждого параграфа и таблицы создается узел (`Node`) и добавляется в иерархию документа.
5. **Обработка нумерации и стилей**: Используется `NumberingDB` для обработки нумерации и стилей параграфов (более подробно описано ниже).
6. **Классификация текста**: При необходимости используется `BERTTextClassifier` для классификации текста.
7. **Формирование**: После обработки всего содержимого, документ готов для экспорта в HTML или JSON.

## Пример использования
Экспорт в HTML

```python
from doc_parse import DocHandler, DocHTML

handler = DocHandler(doc)
converter = DocHTML()

html_content, toc_links = converter.get_html(handler)
```

Экспорт в JSON

```python
from doc_parse import DocHandler, DocJSON

handler = DocHandler(doc)
converter = DocJSON()

json_content = converter.get_html(handler)
```

Экспорт в HTML и JSON (используется один DocHandler, чтобы избежать повторной обработки документа)

```python
from doc_parse import DocHandler, DocHTML, DocJSON

                doc = docx.Document(temp_file.name)
                handler = DocHandler(doc)
                
                # Convert to HTML
                html_converter = DocHTML()
                html_content, toc_links = html_converter.get_html(handler)

                os.unlink(temp_file.name)

                # Convert to JSON
                try:
                    json_converter = DocJSON()
                    json_content = json_converter.get_json(handler)

json_content = converter.get_html(handler)
```

## Расчет нумерации с NumberingDB
### Инициализация класса `NumberingDB`

При создании экземпляра класса `NumberingDB`, выполняются следующие действия:

1. **Инициализация параметров**:
   - `doc`: DOCX документ для обработки.
   - `appendix_header_length`: Максимальная длина заголовка приложения.
   - `default_levels`: Количество уровней нумерации по умолчанию.
   - `default_font`: Размер шрифта по умолчанию.
   - `norm_numeration_model`: Путь к модели для классификации нумерованных заголовков.
   - `norm_heading_model`: Путь к модели для классификации ненумерованных заголовков.

2. **Парсинг XML нумерации**:
   - Извлекает XML-данные нумерации из DOCX документа.
   - Если парсинг не удался, устанавливает `self.num_xml` в пустой словарь.

3. **Инициализация дефолтных абстрактных уровней**:
   - Создает дефолтные уровни нумерации с помощью `self.init_default_abstract`.

4. **Получение и связывание уровней и абстрактных уровней**:
   - Извлекает уровни и абстрактные уровни из XML-данных.
   - Связывает номера с абстрактными уровнями и стили с абстрактными уровнями.

5. **Инициализация инкремента нумерации**:
   - Создает словарь для отслеживания инкремента нумерации.

6. **Инициализация классификаторов**:
   - Загружает модели BERT для нормализации нумерации и заголовков.

7. **Определение стоп-символов**:
   - Устанавливает список стоп-символов, которые могут влиять на обработку нумерации.

### Обработка параграфа в функции `NumberingDB.numerize`

Функция `NumberingDB.numerize` обрабатывает параграф, пытаясь определить и нормализовать его нумерацию. В этой функции происходит следующее:

1. **Обновление статистики размера шрифта**:
   - Добавляет размер шрифта параграфа в список `self.font_size`.

2. **Определение приоритета методов обработки**:
   - Устанавливает порядок применения методов для обработки нумерации:
     1. `numrize_by_meta`: Обрабатывает нумерацию по метаданным.
     2. `numrize_by_style`: Обрабатывает нумерацию по стилю.
     3. `numerize_by_text`: Определяет нумерацию в текстовом префиксе.
     4. `numerize_by_heading`: Обрабатывает нумерацию по заголовку.
     5. `numerize_by_appendix`: Определяет нумерацию для приложений.

3. **Применение методов обработки**:
   - Последовательно применяет каждый метод из списка `numerize_prioritet` к параграфу.
   - Если какой-либо метод успешно определил нумерацию (`par.node.num_prefix` не пустой), останавливает дальнейшую обработку.

4. **Возврат обработанного параграфа**:
   - Возвращает параграф с установленной нумерацией (если она была определена).

### Подробности методов обработки

- **`numrize_by_meta`**:
  - Извлекает `numId` и уровень нумерации из XML-данных параграфа.
  - Получает абстрактный ID нумерации.
  - Считает встроенную нумерацию для данного абстрактного ID и уровня.
  - Проверяет, является ли параграф заголовком и корректирует глубину нумерации.
  - Проверяет наличие стоп-символов в префиксе нумерации и начале текста.

- **`numrize_by_style`**:
  - Получает абстрактный ID нумерации по стилю параграфа.
  - Считает встроенную нумерацию для данного абстрактного ID и уровня.

- **`numerize_by_text`**:
  - Определяет нумерацию в текстовом префиксе параграфа.
  - Проверяет наличие стоп-символов в начале текста.
  - Проверяет, является ли параграф заголовком.
  - Проверяет результат классификатора для нормализации нумерации.

- **`numerize_by_heading`**:
  - Проверяет, является ли параграф заголовком.
  - Проверяет результат классификатора для нормализации заголовков.

- **`numerize_by_appendix`**:
  - Определяет, является ли параграф заголовком приложения.
